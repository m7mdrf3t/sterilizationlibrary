/** * Auther : M7md Rf3t * Description : header file for strilaztion * @Gethup:https://gist.github.com/m7mdrf3t/d57f8623533921a408fe969092784e29 */// include the header file #include "Str_lib.h"#include <LiquidCrystal.h>#include <EEPROM.h>#include "Arduino.h"const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2;LiquidCrystal lcd(rs, en, d4, d5, d6, d7);#include <Keypad.h>//__keypadconst byte ROWS = 4; //four rowsconst byte COLS = 4; //four columns char keys[ROWS][COLS] = {  {'A','2','3','1'},  {'B','5','6','4'},  {'D','0','#','*'},  {'C','8','9','7'},};byte rowPins[ROWS]={14,15,16,17};byte colPins[COLS]={21,20,19,18};Keypad keypd = Keypad(makeKeymap(keys),rowPins,colPins,ROWS,COLS);#define cleanWater_sv    43#define wasteWater_sv    41#define normalOpen_sv    39#define bacterialAir_sv  51 #define feedingPumb      45#define steamGenerator  49#define steamGenerator2  52#define vaccumePumb      47#define doorSwitch      70 #define temp_sen      A1#define sg_sens       A2#define pers_sen      A3#define timeInMintes 60000#define isFirstCyclechar cyc_num;char cyc_typ; typedef unsigned char byte ;//=====================================================================================================================================//__constractor and de-constractor for the striaization library //======================================================================================================================================Str_lib::Str_lib(){  lcd.begin(16, 2);  // Print a message to the LCD.  lcd.print("push 1 for 121*c cycle .. ");  Serial.begin(9600);  Serial.println("chosee what you want ?");  pinMode(cleanWater_sv ,OUTPUT);  pinMode(wasteWater_sv ,OUTPUT);  pinMode(normalOpen_sv ,OUTPUT);  pinMode(bacterialAir_sv ,OUTPUT);  pinMode(feedingPumb ,OUTPUT);  pinMode(steamGenerator ,OUTPUT);  pinMode(vaccumePumb ,OUTPUT);  pinMode(doorSwitch ,INPUT);  pinMode(temp_sen,INPUT);  pinMode(pers_sen,INPUT);  pinMode(sg_sens,INPUT);}Str_lib::~Str_lib(){}//=====================<< checking systems variable >>=======================================================================================//@ it returns true if all variable is achived //========================================================================================================================================bool Str_lib::checkSystems(void){  bool is_cl_Wr_lw  = digitalRead(cleanWater_sv);  bool is_wst_Wr_h  = digitalRead(wasteWater_sv);  bool is_no_Op   = digitalRead(normalOpen_sv);  bool is_bac_Ar_op = digitalRead(bacterialAir_sv);  bool isdr_Op      = digitalRead(doorSwitch); digitalWrite(bacterialAir_sv,LOW);  // power failuer checker  if (EEPROM_chk(0)==1)  {    lcd_display(true , "  E 1  VAC   " , "" , false,true);    while(true){    //inifint loop till press button.    lcd_display(false , "  E 1  VAC   " , " press # to out" , false,false);	char key =keypd.getKey();	if(key=='#'){		EEPROM_Update(5);		Cycle_choo();		break;	}    }  }  if (EEPROM_chk(0)==2)  {    lcd_display(true , "  E 2  HEAT   " , "" , false,true);    while(true){    //inifint loop till press button.    lcd_display(false , "  E 2  HEAT   " , " press # to out" , false,false);	char key =keypd.getKey();	if(key=='#'){		EEPROM_Update(5);		Cycle_choo();		break;	}    }  }  if (EEPROM_chk(0)==3)  {    lcd_display(true , "  E 3  DRY   " , "" , false,true);    while(true){    //inifint loop till press button.    lcd_display(false , "  E 3  DRY   " , " press # to out" , false,false);	char key =keypd.getKey();	if(key=='#'){		EEPROM_Update(5);		Cycle_choo();		break;	}    }  }  if (EEPROM_chk(0)==6)  {    lcd_display(true , "   E 6  steam   " , "" , false,true);    while(true){    //inifint loop till press button.    lcd_display(false , "   E 6  steam   " , " press # to out" , false,false);	char key =keypd.getKey();	if(key=='#'){		EEPROM_Update(5);		Cycle_choo();		break;	}    }  }  if (!isdr_Op)  {    lcd_display(false ,"door is open , close it \n gg " , "" , false ,false );    Error(3);    // checkSystems();  }  if (!is_cl_Wr_lw)  {    lcd_display(false ,"someThing Wrong" , "" , false ,false );    Error(4);    checkSystems();  }  if (is_wst_Wr_h)  {  	lcd_display(false ,"someThing Wrong" , "" , false ,false );    Error(5);    checkSystems();  }  if (!is_no_Op)  {    digitalWrite(normalOpen_sv,HIGH);  }  if (is_bac_Ar_op)  {    digitalWrite(bacterialAir_sv,LOW);  }    Serial.println("checking completed .. carring on \n ");  return true ;}//========================<< steam_generator readings >>=================================================================================//==========================================================================================================================================int16_t Str_lib::SGReads(){  int16_t sg = analogRead(sg_sens)/10;  return fabs(sg) ; }//========================<< pressure readings >>========================================================================================//=========================================================================================================================================int16_t Str_lib::presureReads(){  int16_t pressure = analogRead(pers_sen);  int16_t inBar = map(pressure,37,492,-10,25);  int16_t inFraction =  inBar/10;  return pressure/10 ;}//========================<< Tempreture readings >>=======================================================================================//========================================================================================================================================int16_t Str_lib::tempRead(){  //until we caliberate the tempreture sensor  int16_t tempo = analogRead(temp_sen);  return tempo/10 ;}//============================<< pulse >>================================================================================================//=====================================================================================================================================void Str_lib::pulses(bool pulseState, uint32_t aftePulseDelay){  //make sure we begin from zero .  digitalWrite(vaccumePumb , LOW);  digitalWrite(wasteWater_sv ,LOW);  bool vp_dev = false ;  bool ww_sv = false ;   //readings --------------------------------------------    Readings();    lcd_Readings();  //-----------------------------------------------------  if (pulseState){    digitalWrite(feedingPumb , HIGH);    digitalWrite(cleanWater_sv, HIGH);    delay(aftePulseDelay);    digitalWrite(feedingPumb , LOW);    digitalWrite(cleanWater_sv , LOW);  delay(2000);  Serial.println(analogRead(temp_sen));  }else{    digitalWrite(feedingPumb , LOW);    digitalWrite(wasteWater_sv , LOW);    delay(800); }}//==========================<< open selonide valve >>=================================================================================//======================================================================================================================================void Str_lib::OpenSV(uint16_t pressToVacc){  while(true){  digitalWrite(normalOpen_sv,LOW);  Serial.println("------------------------------------------------------------------------------------------------");  Serial.println("waiting N.open sv is working..");  lcd_display(true , "waiting N.open sv is working.." , "" , false,true);  //readings --------------------------------------------    Readings();    lcd_Readings();    //-----------------------------------------------------  delay(400);  uint16_t press=presureReads();    if(press<pressToVacc){      digitalWrite(normalOpen_sv,HIGH);      Serial.println("end");          delay(400);      break;    }       }}//==========================<< steaming >>=============================================================================================//====================================================================================================================================void Str_lib::Steaming(uint32_t nt_excedd_time, bool heatState ,int16_t G_req_temp , int16_t G_req_pressure , int16_t G_SGtemp, int16_t G_ST_min_temp ){    //EEPROM updating   EEPROM_Update(6);  int8_t count ;  count++;  digitalWrite(steamGenerator , HIGH);  digitalWrite(steamGenerator2 , HIGH);  int16_t champer_temp =  tempRead();  int16_t steamGenTempSensor = SGReads();  int16_t pressureNow = presureReads();  uint32_t currentTime =millis();   //readings --------------------------------------------    Readings();    lcd_Readings();  //-----------------------------------------------------  while(true){     int16_t champer_temp =  tempRead();    int16_t steamGenTempSensor = SGReads();    int16_t pressureNow = presureReads();    //-----------------------------------------------------------------    Readings();    lcd_Readings();    //------------------------------------------------------------------    if (champer_temp <= G_req_temp && pressureNow <= G_req_pressure)    {    digitalWrite(normalOpen_sv,HIGH);  digitalWrite(steamGenerator,HIGH);    digitalWrite(steamGenerator2,HIGH);    Serial.println("------------------------------------------------------------------------------------------------");      Serial.println(" giving pulses && Heating From SG");       lcd_display(true , "pulse && Heating" , "" , false,true);      delay(500);      if (steamGenTempSensor > G_ST_min_temp)       {       	pulses(true , 2000);       }           }    else    {   digitalWrite(normalOpen_sv,HIGH);     digitalWrite(steamGenerator,HIGH);     digitalWrite(steamGenerator2,HIGH);     digitalWrite(bacterialAir_sv,LOW);     digitalWrite(vaccumePumb,LOW);     digitalWrite(wasteWater_sv,LOW);     //pulses(false , 0);     Serial.println("------------------------------------------------------------------------------------------------");   Serial.println("Heating Stoped");   lcd_display(true , "Heating Stoped" , "" , false,true);   delay(500); //-----------------------for testing reasons keep break slashed :) -------------------     //break;         }   if (steamGenTempSensor > G_SGtemp )   {    Serial.println("------------------------------------------------------------------------------------------------");    Serial.println("supr=er hot gen");    lcd_display(true , "Supr=er Hot Gen" , "" , false,true);    SteamGenerator(G_SGtemp ,true);    }    if ((currentTime+nt_excedd_time)<=millis())    {      Error(2);      break;    }  }}void Str_lib::SteamGenerator(int16_t g_temp , bool isHeat){	while(true){	  //readings --------------------------------------------	    Readings();	    lcd_Readings();	    //-----------------------------------------------------	  int16_t steamGenTempSensor = SGReads();	  if(steamGenTempSensor > g_temp ){	    digitalWrite(steamGenerator,LOW);	    digitalWrite(steamGenerator2,LOW);	    if(isHeat){	      //if the generator is super hot , last pulse finished .. it will give another pulse with no delay (Double pulses)..:>(o	      pulses(true , 2000);	      Serial.println(" hot sG and pulse >>"); 	      lcd_display(true , "Pulse->Hot Gen" , "" , false,true);	    }	  }else{	    break;	  }	}	  }//=======================<< Heating >>=================================================================================================//======================================================================================================================================void Str_lib::heating(uint32_t heatDuration , bool heatState , int16_t G_req_temp  , int16_t G_req_pressure, int16_t G_ST_max_temp , int16_t G_ST_min_temp){    //EEPROM updating   EEPROM_Update(2);  uint8_t count ;  count++;  digitalWrite(steamGenerator , HIGH);    digitalWrite(steamGenerator2 , HIGH);  uint16_t champer_temp =  tempRead();  uint16_t steamGenTempSensor = SGReads();  uint16_t pressureNow = presureReads();  uint32_t currentTime = millis();  while(true){    uint16_t champer_temp = tempRead();    uint16_t steamGenTempSensor = analogRead(sg_sens);    uint16_t pressureNow = presureReads();    //readings --------------------------------------------    Readings();    lcd_Readings();    //-----------------------------------------------------        if (champer_temp <= G_req_temp && pressureNow <= G_req_pressure )    {    digitalWrite(normalOpen_sv,HIGH);    digitalWrite(steamGenerator , HIGH);      digitalWrite(steamGenerator2 , HIGH);      Serial.println("pulses and heating");      lcd_display(true , "pulse && heating" , "" , false,true);      delay(700);      if (steamGenTempSensor > G_ST_min_temp)      {      	pulses(true , 2000);      }     }    else    {    digitalWrite(normalOpen_sv,HIGH);      digitalWrite(steamGenerator,HIGH);      digitalWrite(steamGenerator2,HIGH);      digitalWrite(bacterialAir_sv,LOW);      digitalWrite(vaccumePumb,LOW);      digitalWrite(wasteWater_sv,LOW);        Serial.println("nor pulses nor heating the steam G stoped");        lcd_display(true , "NO heating" , "" , false,true);        delay(700); //-----------------------for testing reasons keep break slashed :) -------------------      //break;    }  SteamGenerator(G_ST_max_temp , true);    if((currentTime+heatDuration) <= millis())    {      Serial.println("heating ending");       lcd_display(true , "Heating Ending" , "" , false,true);      delay(700);      Error(2);      break;    }  }} //=============================<< dry >>=============================================================================================//====================================================================================================================================void Str_lib::Drying(uint32_t reqTime , int16_t zeroPress , int16_t finaltemp , uint32_t fentTime){    //EEPROM updating   EEPROM_Update(3);  int16_t pressureIs = presureReads();  int16_t champer_temp =  tempRead();  uint32_t dryTimelapsed;  uint32_t currentTime;  currentTime = millis();  while(true){    int16_t pressureIs = presureReads();    int16_t champer_temp =  tempRead();    //readings --------------------------------------------    Readings();    lcd_Readings();    //-----------------------------------------------------    if (champer_temp <= finaltemp && pressureIs <= zeroPress)    {      Serial.println("champer seems to be cold ...:( ");      delay(1000);      break;    }else{      digitalWrite(vaccumePumb , HIGH);    // preferd to be high to make sure       digitalWrite(wasteWater_sv , HIGH);  // preferd to be high to make sure       digitalWrite(normalOpen_sv , LOW);  //preferd to be low to make sure water and pressure are gone      lcd_display(true , "  Dry  " , "" , false,true);       delay(1000);          }    if ((currentTime+reqTime)<= millis())     {      Serial.println("time is running up ");      break;     }   }  digitalWrite(vaccumePumb , LOW);    // preferd to be high to make sure   digitalWrite(wasteWater_sv , LOW);  digitalWrite(normalOpen_sv , HIGH);  digitalWrite(bacterialAir_sv ,HIGH);  lcd_display(true , "  Fent  " , "" , false,true);  delay(fentTime);   Serial.println("fentilation finished..");  delay(500);}//============================<< vaccume >>=========================================================================================// vaccume for set periode of time//================================================================================================================================void Str_lib::Vaccume(int16_t presNeed , uint32_t nt_excedd_time){    //EEPROM updating   EEPROM_Update(1);  int16_t pressureIs = presureReads();  uint32_t currentTime= millis();;  while(true){    int16_t pressureIs = presureReads();  digitalWrite(steamGenerator,HIGH);    digitalWrite(steamGenerator2,HIGH);    digitalWrite(vaccumePumb , HIGH);    digitalWrite(wasteWater_sv , HIGH);  digitalWrite(normalOpen_sv,HIGH);  digitalWrite(bacterialAir_sv,LOW);  digitalWrite(feedingPumb , LOW);    Serial.println("------------------------------------------------------------------------------------------------");    Serial.print("vacumeing...");    lcd_display(true , "VAccumeing.." , "" , false,true);    delay(500);    //readings --------------------------------------------    Readings();    lcd_Readings();    //-----------------------------------------------------    delay(500);    if(presNeed<= pressureIs){      digitalWrite(vaccumePumb , LOW);      digitalWrite(wasteWater_sv , LOW);    digitalWrite(normalOpen_sv,HIGH);    digitalWrite(bacterialAir_sv,LOW);    Serial.println("------------------------------------------------------------------------------------------------");    Serial.print("no ... vacumeing...");    lcd_display(true , "VAccume Stop.." , "" , false,true);    //---- for testimg reasones -------       //break;    }    //___ make sure the SG heater is checked out here > else it will blow up :)   //  if(steamGenTempSensor>G_ST_max_temp)   //  {   //    digitalWrite(steamGenerator,LOW);    //    digitalWrite(steamGenerator2,LOW);    // Serial.println("supr=er hot gen");    // SteamGenerator(G_ST_max_temp , false);   //  }    if((nt_excedd_time+currentTime)<=millis())    {      Error(1);      break;    }  }}/*******************************************************************************************                                                                                         ** function: lcd display.                                                                  ** Discription: displaying comments pressure and t-                                        ** empreture at the lcd display.                                                           **                                                                                         *********************************************************************************************/void Str_lib::Treminate(void){  EEPROM_Update(5);    digitalWrite(steamGenerator,HIGH);  digitalWrite(steamGenerator2,HIGH);  digitalWrite(cleanWater_sv , LOW);      digitalWrite(vaccumePumb , LOW);  digitalWrite(wasteWater_sv , LOW);  digitalWrite(normalOpen_sv,HIGH);  digitalWrite(bacterialAir_sv,LOW);  digitalWrite(feedingPumb , LOW);  lcd_display(true , " Triminating  " , "" , false,true);  delay(2000);}//============================<< debuger >>==============================================================================================// vaccume for set periode of time//======================================================================================================================================/** * [Str_lib::Error helps you to know where is the fault is ] * @param ID give feedback about where the fault happens */void Str_lib::Error(int8_t ID){ switch (ID){  case 1:  Serial.println("Error 1001 .. vaccume time Exceeded");  lcd_display(true , "NO heating" , "" , false,true);  delay(1500);  break;  case 2:  Serial.println("Error 2002 .. heating time Exceeded");  lcd_display(true , "NO heating" , "" , false,true);  delay(1500);  break;  case 3:  Serial.println("Error 3003 .. door is still open");  lcd_display(true , "E open-door" , "" , false,true);  delay(1500);  break;  case 4:  Serial.println("Error 4004 .. check water levels");  lcd_display(true , "E C-w" , "" , false,true);  delay(1500);  break;  case 5:  Serial.println("Error 4004 .. check water levels");  lcd_display(true , "E W-w" , "" , false,true);  delay(1500);  break; }}//=======================<< pressure readings >>=======================================================================================//=====================================================================================================================================void Str_lib::display(char * comment , int d_t  ){  Serial.println(comment);  delay(d_t);}void Str_lib::Readings(void){  Serial.println("");  Serial.print("      tempreture : ");  Serial.print(tempRead());  Serial.print("      S G :  ");    Serial.print(SGReads());  Serial.print("      Pressure : ");    Serial.print(presureReads());    Serial.print("      Time in sec: ");    Serial.print(millis()/1000);    Serial.println("");}/*****************************************************                                                   ** function: lcd display.                            ** Discription: displaying comments pressure and t-  ** empreture at the lcd display.                     **                                                   *******************************************************/void Str_lib::lcd_display(bool trim_befor , char* comm1 , char* comm2 , bool trim_after , bool read){  if (trim_befor)  {    lcd.clear();  }  if (comm1)  {	 if (read){	  	lcd.setCursor(0,0);		  lcd.print("Temp:");		  lcd.print(tempRead());		  lcd.write(" ");		  lcd.setCursor(9,0);		  lcd.print("P:");		  lcd.print(presureReads());		  lcd.write(" ");	 } 	  lcd.setCursor(0,2);  lcd.write(comm1);  }  if (comm2)  {    lcd.setCursor(0,0);    lcd.write(comm2);  }  if (trim_after)  {    delay(2000);    lcd.clear();  }}  void Str_lib::lcd_Readings(void){  lcd.setCursor(0,0);  lcd.print("Temp:");  lcd.print(tempRead());  lcd.write(" ");  lcd.setCursor(9,0);  lcd.print("P:");  lcd.print(presureReads());  lcd.write(" ");    lcd.setCursor(0,1);  lcd.write("SG:");  lcd.print(SGReads());  lcd.write("   ");    lcd.setCursor(8,1);  lcd.print("sec:");  lcd.print(millis()/1000);  lcd.write("  ");  delay(100);}/**********************************************************************************  Clear lcd display                                                             **                                                                                ************************************************************************************/void Str_lib::ems7(void){ lcd.clear();  }/**********************************************************************************                                                                                ** __EEPROM check up                                                              **                                                                                ************************************************************************************/void Str_lib::EEPROM_Update(uint8_t proceesNumb){  uint8_t address = 0;  EEPROM.update(address , proceesNumb);    // if (address == EEPROM.length()) {   //  address = 0;  // }}uint8_t Str_lib::EEPROM_chk(uint8_t address){  return EEPROM.read(address);   }void Str_lib::Cycle_choo(){  bool isSystemsOk =checkSystems();  if(isSystemsOk)  {  	lcd_display (true , "Enter Cycle Num" , "" ,true ,false);  // uint8_t cyc_typ ;  while(true){    lcd_display (false , "1 for 121C & 1.2B" , "2 for 134C & 2.1B" ,false,false);	cyc_num =keypd.getKey();	if (cyc_num)	{	ems7();	lcd_display (true , "           " , "button press num   " ,false,false);    delay(2000);    //cyc_num = (uint8_t)kbord.getKey();    if (cyc_num == '1' || cyc_num == '2' )	    {	    lcd_display (true ,"break num..........", "              " ,false,false);	    delay(1000);     	break;	    }	}	  }   while(true){    lcd_display (false , " 1 for wrapped" , " 2 for plastic" ,false,false);    cyc_typ =keypd.getKey();    if (cyc_typ)    {    ems7();    lcd_display (true ,"button press typ", "         " ,false,false);    delay(2000);    //cyc_typ = (uint8_t)kbord.getKey();	    if (cyc_typ == '1' || cyc_typ == '2' || cyc_typ == '3' )	    {	    	lcd_display (true ,"break typ..........", "            " ,false,false);	        delay(1000);	        break;	    }    }      }  // if (cyc_num && cyc_typ)   // {    if (cyc_num == '1' ){      if (cyc_typ == '1')      {        // cycle 3 134 and 4 par wraaped        lcd_display (true , "Initate Cycle >> " , "134C&2B wraaped" ,false,true);        delay(4000);        Main_cycle(1, 1 , 3);      }      if (cyc_typ == '2')      {        // cycle 3 134 and 4 par wraaped        lcd_display (true , "Initate Cycle >> " , "121C&2B plastic" ,false,true);        delay(4000);        Main_cycle(1,  1 , 3);      }    }    if (cyc_num == '2')    {      if (cyc_typ == '1')      {        // cycle 3 134 and 4 par wraaped        Main_cycle(1,  2 , 3);      }      if (cyc_typ == '2')      {        // cycle 4 134 and 4 par plastic         Main_cycle(1,  2 , 3);      }    }      if (cyc_num == '3')    {      if (cyc_typ == '1')      {        // clean cycle        Main_cycle(1,  2 , 3);      }    }  }  else  {  checkSystems();  }    // }}//**************************************************************void Str_lib::Main_cycle(uint8_t timeForCyc,uint8_t heatingTimeTo,uint8_t DryingTimeTo){    ems7();        Steaming(0.5*timeInMintes,true , 30 , 30, 100,20);    Vaccume(90 ,timeForCyc*timeInMintes);    Steaming(timeInMintes,true , 80 , 80, 100 ,20);    OpenSV(70);    delay(3000);    Vaccume(90 ,timeForCyc*timeInMintes);    Steaming(timeForCyc*timeInMintes,true , 80 , 80, 100,20);    OpenSV(70);    delay(3000);    Vaccume(100 ,timeForCyc*timeInMintes);    Steaming(timeForCyc*timeInMintes,true , 70 , 60, 100,20);    OpenSV(60);    delay(3000);    // uint32_t getReadyTime= millis();    // checkSystems();    heating(heatingTimeTo*timeInMintes,true , 80 , 80, 100,20);        Drying(DryingTimeTo*timeInMintes, 10 , 20, DryingTimeTo*timeInMintes);        Treminate();}